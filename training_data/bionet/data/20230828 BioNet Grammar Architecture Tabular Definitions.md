# BioNet Functions and Definitions## 1. Bionet Project Concept FunctionsThe concept comes from the customer. A concept consists of what the customer wants, the problems they need to solve, their key technical requirements, preferences for approach, and other constraints for the project. An example needs statement is "Make me a tooth whitening enzyme that sticks to teeth". It may not be possible for the project concept functions to process this info much, but at least it's broken down into categories to encourage thinking-through. In the future, we anticipate that large language models and other AI tools will provide most of the material from structured concept proposals.The **stateProblem()** function is a structured way of generating a terse problem statement. The function takes a written description of the problem provided by the customer and returns a terse problem statement. The **listRequirements()** function stores and returns a list of key project requirements. Examples include high solubility, good temperature stability, and high enzyme activity.The **listConstraints()** function returns a list of the key non-technical project constraints. Examples include the amount of funding available and time to testing or time to market. The **stateApproach()** variable stores the technical approach for addressing the concept. An example approach statement  would be: "synthesize a DNA plasmid that expresses a fusion protein".The **createProposal()** function takes the concept info and returns a written project proposal. This project proposal contains a summary of the project, the main technical steps, anticipated problems, steps used to test the product, and steps needs to scale synthesis to commercial volumes. The proposals can be created by professional Bionet proposal writers or by large language models such as BITS-Bionet, or humans working together with humans? The **developWorkflow()** function takes the structured proposal information and proposes one or more alternative workflows. The function returns a written description of each workflow, the major advantages and limitations, and also a visual workflow diagram. ## 2. Bionet Synbio Technical FunctionsThe Bionet Synbio Technical Functions are associated with the request and provision of technical services or products in a Synthetic Biology workflow. ### "Bits" tech functionsSynbio technical functions that request information/computation-based services. ### Design Molecules or Systems functionsFunctions for obtaining designs of proteins, multi-protein systems, or engineered organisms. Generally, "design" is completed when the amino acid sequences of the proteins are specified, with some exceptions for systems with functional nucleic acid components. Mathematical and computer simulations are frequently an important part of the design process. **designChassis()** Returns selection of a Chassis organism and, optionally, assistance with actually procuring it if it is not commonly available. Utilizes info from Concept to make selection. Needs to be done early in a project. Can also involve procurement of the Chassis organism.**designProteins()** Returns amino acid sequences of designed proteins. Inputs: components of Concept.**designMetPathways()** Returns enzyme names, molecular reaction schemes, modeling results for designed pathways, optionally - amino acid sequences of enzymes in designed pathways. Inputs: components of Concept.**designCircuits()** Returns amino acid sequences of protein components and DNA sequences of nucleic acid components of circuits, returns circuit diagrams and logic, modeling results. Inputs: components of Concept.**designEngOrganisms()** Returns list of genetic modifications to Chassis organisms to create engineered organisms, modeling results. Optionally √ê amino acid sequences of heterologous proteins to express. Inputs: components of Concept.**performSimulations()** Returns results of modeling simulations performed. Call this function when you wish to have simulations performed to examine the results, but you do not (yet) want full-fledged designs (sequences) of proteins or other biological systems, such as for genetic circuits or metabolic engineering.**designLibrary()** Returns a description of the library members either as an arrayed list, or as a combinatorial description of fixed and variable portions of the collection. Function can be called to initiate design of all types of protein-based libraries from individual protein mutants to combinatorial metabolic pathways. Usually called along with another Design function such as **designProteins()** or **designMetPathways()**. ### Compose DNA functionsFunctions for composing electronic DNA sequences of various "types." Each of the DNA types here has somewhat different characteristics from the others, motivating the assignment of a different function for each. However, this system of distinction may not stand. More than one function may be called/required for some DNA, such as a library that will be cloned into a plasmid. All of these would take as input any (designed) amino acid sequences to be "translated" into DNA, the Chassis species, plus other parameters describing what features and functionalities are needed in the final compositions.  **composePlasmids()** Returns electronic DNA sequences of complete plasmids. Call if, for example, you would like a designed protein encoded within a plasmid vector, which includes several functional DNA parts for expression of the protein, replication and maintenance of the plasmid in the Chassis and possibly also in E. coli ("shuttle vector"). **composeLinearDNA()** Returns electronic DNA sequences of composed linear DNA constructs. **composeChromosome()** Returns electronic DNA sequence of a composed chromosome (very long DNA). **composeGenomeInt()** Returns electronic DNA sequences of composed DNA constructs intended to become integrated into a genome, either fully or partially. This may not end up standing as an independent function. **composeLibrary()** Returns electronic DNA sequences of composed DNA libraries. Contains parameters for specifying different types of DNA libraries for composition. Usually called with one or more other Compose DNA operations, such as **composePlasmids()**. Examples of types of libraries: individually arrayed, mixed (pooled), combinatorial, point mutation, site-saturation. **composeAssemblyFeatures()** Returns addition of "DNA assembly features" to either already-composed DNA, or to a concurrent request for composed DNA. This may not end up standing as an independent function. ### "Atoms" tech functionsSynbio technical functions that request physical goods, or services involved in making or working with physical items, usually biological entities. ### Make Biological Entity functionsFunctions that order making/fabrication of nucleic acids, proteins, engineered organisms, and the like. ### DNA Fabrication functionsFunctions that request fabrication of DNA**makeDNA()** Returns custom-fabricated DNA from the supplier called within the function. Inputs: electronic DNA sequences and a few other parameters such as quantity, degree of sequence validation, physical state, modifications requested, "rush" or standard timing. **makeDNAArrayedLib()** Returns a physical library or collection of related DNA sequences in which each individual library member is spatially arrayed or separated from the others, e.g., in individual wells of multiwell plates. Unclear if this merits an independent function from **makeDNA()**, but some complexities in describing libraries like this may point to yes. May depend on how vendor APIs handle these types of  libraries.**makeDNAPooledLib()** Returns a special type of fabricated DNA, which is a library or collection of sequences that vary from each other, with all those sequences mixed or pooled together in one sample. Unclear if this merits an independent function, but some complexities in describing libraries like this may point to yes. May depend on how vendor APIs handle these pooled libraries. **makeDNACombiLib()** Returns a special type of fabricated DNA, which is a library or collection of sequences that vary from each other in a "combinatorial" fashion, where each member consists of a combination or permutation subset of a master set of DNA elements or parts. Library could be pooled or individually arrayed. Unclear if this merits an independent function.### Strain Construction functionsStrain construction always involves transforming of DNA into an organism. In a simple case, the DNA is a self-replicating plasmid that coexists with the genome (for a period of time at least) and whose encoded proteins or functionalities are expressed. An organism augmented with a plasmid is considered to be a new strain. More complex, laborious, and interesting are cases where the transformed DNA becomes integrated into the host's genome to effect a deletion, insertion, or edit. This integration may have a random component, such as with a transposon, or may be targeted to specific bases in the genome by homologous recombination. **transformDNA()** Returns new strains that have been successfully transformed with the DNA specified in the function's parameters. Other parameters include the degree of genetic or phenotypic validation of the transformed strains, number of transformants ("clones"), transformation protocol to use. **modifyGenome()** Returns new strains whose genomes have been successfully modified. Can be considered an "extension function" of **transformDNA()**. The DNA itself needs to have characteristics that will effect genome modification. The protocols followed during and after transformation also have a substantial effect on genome modification. Parameters: the degree of genetic or phenotypic validation of the modified strains, number of transformants ("clones"), transformation protocol to use.### "Shortcut Make" functionsThere are "shortcut routes" to having things like proteins or engineered organisms made by companies or entities with capabilities for multiple operations or the technology to produce things by other means that involve fewer or totally different steps (perhaps not via synthetic biology). These may be worth including, since some customers pay prioritize speed over cost, for example. **makeProteinDirect()** Returns physical custom proteins from input amino acid sequences and a few other parameters. These providers perform (or outsource themselves) the steps of DNA Composition, DNA Fabrication, Strain Construction, Culturing and Expression, and Sample Preparation (Protein Purification). See, for example, https://www.bonopusbio.com/e-coli-expression.**makeSmallMolDirect()** Returns the physical small molecules requested and, optionally, the constructed strains used to produce them, in response to a request for those molecules. Such a provider may perform (or outsource themselves) the steps of  Metabolic Pathway Design, DNA Composition, DNA Fabrication, Strain Construction, Culturing and Expression, and Sample Preparation (Product Purification). Example provider: Conagen. **makeEngOrgDirect()** Returns an engineered organism directly in response to a call describing the required characteristics or specific genetic modifications to be made to an organism. Example provider: Ginkgo Bioworks.### Manufacturing functions**produceMaterial()** Returns the specified quantity of manufactured Synbio product. Generally called once the producing strain, manufacturing process, etc. are already in place.### Test Biological Entity functions### Culturing and Expression functions**culture_Express()** Returns completion of a Culturing and Expression operation, where organisms are grown under controlled conditions for the purpose of using them to express or produce protein or small molecule products, or to amplify the organisms themselves if they are the product. Measurements that do not require sample preparation may be collected as part of this operation. So-called "cell-free" protein expression can also be requested with this function. In this case, DNA and a cell-free expression "platform" would be specified as input parameters.  **developCEProtocol()** Returns a protocol for culturing and expression for cases where a suitable one is not available. May involve experimentation or may come exclusively from subject matter expertise. Parameters would specify the organism, goals, and constraints for a culturing and expression protocol. ### Performance Evaluation functionsPerformance Evaluation comprises most of the measurements of the performance of the organism or products thereof. Generally fits between Culturing and Expression and Data Analysis or Production. Entire libraries of variants of organisms, proteins, or pathways may be subjected to Performance Evaluation. Design, piloting, and refinement of the protocol and assays to be conducted are  part of the Performance Evaluation element.**prepareSamples()** Returns completion of a Sample Preparation operation. Sample preparation is usually performed on cultured biomass or other products of culturing and expression such as spent growth medium. This step involves enrichment or purification of certain components, such as the protein(s) or small molecule(s) of interest, which is commonly required before certain measurements or assays can be performed or for release/sale of those materials. **measure()** Returns completion of a Measurement operation. Call this function to have "standard" or fairly simple/routine laboratory measurements performed. This includes simple procedures with few steps (e.g., < 3) such as determining mass with a balance or UV-visible absorbance on a spectrophotometer or plate reader.developAssay()** Returns an assay protocol. Call this function to have a new assay procedure developed or adapted. May involve experimentation or may come exclusively from subject matter expertise, but should be experimentally validated. Parameters must specify detailed information on what is known and desired, as well as suggestions on where to start, such as literature references to existing assays.**runAssay()** Returns completion of an Assay Samples operation. Call this function to have an assay performed. Assays, in contrast to measurements, have multiple steps and tend to be customized for specific outcomes such as determining the activity of a particular enzyme in a sample. A step-by-step protocol should be available and referenced in the parameters to help ensure the assay is run exactly as desired. ## 3. Bionet Decision Support (DS) and Systems Integration (SI) functionsDecision Support functions are data/informational/computational functions that Systems Integrators can call to access specialized analysis and decision support on projects. ### Decision Support functionsFunctions that help Systems Integrators or Customers make big project decisions. **generateDecisionTree()** Returns a logic flowchart diagram highlighting key decision points for a workflow or project. May be a "self" function called and fulfilled by the Systems Integrator, or potentially fulfilled by an external provider or AI. **makeWorkflowDecision()** Returns a project management decision marked on the project's Decision Tree, such as "perform another round of strain engineering." Function itself may be "empty" and merely serve to document decisions and their inputs and rationale, or they may call for help with a decision from an expert or an AI algorithm. **designExperiments()** Returns an experimental scheme detailing combinations of input variable settings to run and data to be collected. A "designed experiment" often refers to a "statistically designed experiment" or "Design of Experiments (DoE)". The parameters for this operation may need to be quite open-ended and prose-heavy. Specialized experts such as statisticians and Six Sigma practitioners can generate experimental designs that will efficiently and economically achieve the Customer's needs for determining, for example, key variables responsible for output variation or performance, or combinations of independent variable values that optimize the output.### Systems Integrator Support functionsFunctions that Systems Integrators can "call for help" to have specialized professionals perform important project tasks such as advanced statistical analysis or generate reports on project economics.**analyzeEconomics()** Returns a Techno-Economic Analysis (TEA) report that investigates the potential profitability and main drivers thereof of the biotechnology process or product in question. List of appropriate parameters should come from TEA professionals. Returns a recommendation for a concrete project decision for which the SI has requested advice. Example: after receiving Performance Evaluation data below specifications for profitability, should the Chassis organism be changed, should another round of protein or organism engineering be performed, or should the entire project be shut down? **performRegulatoryAnalysis()** Returns a government regulatory analysis report that lists the various regulatory bodies likely to be involved in approval of the desired product or service for the marketplace in one or more countries/regions and provides an assessment of the contents required within the applications to those regulatory to achieve approval. **writeRegulatoryApplication()** Returns a completed application to a government regulatory body for approval or designation of the product or service to be marketed. ### Results Analysis FunctionsFor particularly large or complex datasets, Systems Integrators may require assistance with analysis or visualization.**performStatAnalysis()** Returns a statistical analysis report for a project dataset. Call this function to have data or results analyzed by a professional statistician, data scientist, or equivalent. **performDataVisualization()** Returns a specialized visualization module or report for a project dataset, e.g., made with special interactive software such as Tableau or Spotfire. ## 4. Bionet Utility FunctionsThe Bionet utility functions that are called as part of or adjacent to several elements or operations in a workflow or project. All of these may not fit as full-fledged independent functions. ### Information **shareReferences()** Causes specified references (literature papers, patents, etc.) to be shared with a recipient when called. Unclear if this merits an independent function or whether it should be a widespread parameter within other functions. **shareSafetyInfo()** Causes germane safety information to be shared with the same recipient as an "adjacently called" function when called. Unclear if this merits an independent function or whether it should be a widespread parameter within other functions.### Material**handleMaterials()** Returns completion of the specified material handling steps or instructions. May not rise to the level of an independent function. **transferMaterials()** Returns completion of the specified material transfer steps or instructions, e.g., shipping from one performer to the next. May not rise to the level of an independent function.**labelSamples()** Returns completion of the specified sample/material labeling steps or instructions, e.g., "label samples 1, 2, and 3 as 'x1', 'x2', and 'x3, respectively". May not rise to the level of an independent function.